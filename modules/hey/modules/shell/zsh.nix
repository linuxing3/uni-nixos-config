{ hey, lib, config, options, pkgs, ... }:

with lib;
with hey.lib;
let cfg = config.modules.shell.zsh;
in {
  options.modules.shell.zsh = with types; {
    enable = mkBoolOpt false;

    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to ${config.home.configDir}/zsh/extra.zshenv and
      sourced by $XDG_CONFIG_HOME/zsh/.zshenv
    '';

    rcFiles  = mkOpt (listOf (either str path)) [];
    envFiles = mkOpt (listOf (either str path)) [];
  };

  config = mkIf cfg.enable {
    programs.zsh = {
      enable = true;
      # I init completion myself, because enableGlobalCompInit initializes it
      # too soon, which means commands initialized later in my config won't get
      # completion, and running compinit twice is slow.
      enableCompletion = true;
      enableGlobalCompInit = false;
      # Again. I configure the prompt myself, so disable the default.
      promptInit = "";
      # Respect XDG please!
      histFile = "$XDG_STATE_HOME/zsh/history";
      # Implement these manually (and with caching)
      enableLsColors = false;
    };

    users.defaultUserShell = pkgs.zsh;

    # Some interactive shell utilies I find universally indispensible.
    user.packages = with pkgs; [
      at
      bat      # a better cat
      bc
      dust     # a better du
      eza      # a better ls
      fasd
      fd
      fzf
      gnumake
      libqalculate  # calculator cli w/ currency conversion
      nix-zsh-completions
      ripgrep  # a better grep
      tokei    # for code statistics
      unar
      vim
    ];

    # Ensure XDG compliance
    environment.variables = {
      ZDOTDIR = "$XDG_CONFIG_HOME/zsh";
      ZGEN_DIR = "$XDG_DATA_HOME/zgenom";
      _FASD_DATA = "$XDG_CACHE_HOME/fasd";
      _FASD_VIMINFO = "$XDG_CACHE_HOME/viminfo";
    };

    # Ensure that ZSH's cache directory exists, lest we have IO errors early on.
    systemd.user.tmpfiles.rules = [
      "d %h/.cache/zsh 750 - - - -"
      "d %h/.local/state/zsh 700 - - - -"
    ];

    home.configFile = {
      # Link individual files (recursively), rather than whole directory, so
      # other modules (or the user) can write files there later.
      "zsh" = { source = "${hey.configDir}/zsh"; recursive = true; };

      # Why extra.zsh{rc,env} when I could be using extraInit? Because extraInit
      # generates those files in /etc/profile, and mine just write the files to
      # ~/.config/zsh; where it's easier to edit and tweak them in case of
      # issues or when experimenting.
      "zsh/extra.zshrc".text = ''
         # This file was autogenerated, do not edit it!

         # modules.shell.zsh.rcInit
         hey.cache fasd --init posix-alias zsh-{hook,{c,w}comp{,-install}}
         hey.cache ${pkgs.coreutils}/bin/dircolors -b
         ${cfg.rcInit}

         # modules.shell.zsh.rcFiles
         ${concatMapStringsSep "\n\n" builtins.readFile cfg.rcFiles}
      '';

      "zsh/.zshenv".text = ''
        # This file is autogenerated, do not edit it!

        # Be more restrictive with permissions in $HOME; no one has any business
        # reading things that don't belong to them.
        if (( EUID != 0 )); then
          umask 027
        else
          # Be even less permissive if root.
          umask 077
        fi

        # modules.shell.zsh.envInit
        ${cfg.envInit}

        # modules.shell.zsh.envFiles
        ${concatMapStringsSep "\n\n" builtins.readFile cfg.envFiles}
      '';
    };

    # Delete compiled zgenom state, so that everything can rebuild from scratch.
    hey.hooks.reload."80-zsh" = ''
      rm -fv "$ZGEN_DIR"/init.zsh
      rm -frv "$XDG_CACHE_HOME"/zsh/*(DN)
      rm -fv "$ZDOTDIR"/**/*.zwc(D.N)
    '';
  };
}
